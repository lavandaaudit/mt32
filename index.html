<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIVE MODULARXIII</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap"
        rel="stylesheet">
</head>

<body>
    <div id="app">
        <header class="top-bar">
            <h1>LIVE MODULARXIII</h1>
            <div class="master-controls">
                <div class="master-controls" style="display:flex; gap:10px; align-items:center;">
                    <button id="power-btn" class="neon-btn">POWER</button>
                    <div id="master-knobs" style="display:flex; gap:4px;"></div>
                </div>
            </div>
        </header>

        <main class="modular-grid">
            <!-- INPUT / CONTROL LAYER -->
            <section class="module control-layer">
                <h2>CONTROL</h2>
                <div class="module-content">
                    <div class="keyboard-controls">
                        <button class="octave-btn" data-action="down">- OCT</button>
                        <span id="current-octave">OCT 4</span>
                        <button class="octave-btn" data-action="up">+ OCT</button>
                    </div>
                </div>
            </section>

            <!-- SEQUENCER LAYER -->
            <section class="module sequencer-layer">
                <h2>SEQUENCER (32 STEP)</h2>
                <div class="sequencer-controls">
                    <button id="seq-play" class="transport-btn">PLAY</button>
                    <button id="seq-stop" class="transport-btn">STOP</button>
                    <div class="tempo-control">
                        <label>BPM</label>
                        <input type="number" id="bpm-input" value="120" min="40" max="240">
                    </div>
                </div>
                <div class="step-grid" id="step-grid">
                    <!-- Steps injected by JS -->
                </div>
            </section>



            <!-- SOUND GENERATION CORE -->
            <section class="module osc-bank">
                <h2>OSCILLATOR BANK</h2>
                <div class="oscillators-container" id="osc-container">
                    <!-- Oscillators injected by JS -->
                </div>
            </section>

            <!-- FX MATRIX -->
            <section class="module fx-matrix">
                <h2>FX MATRIX</h2>
                <div class="fx-grid" id="fx-grid">
                    <!-- FX slots injected by JS -->
                </div>
            </section>

            <!-- MODULATION MATRIX -->
            <section class="module mod-matrix">
                <h2>MODULATION</h2>
                <div class="mod-grid" id="mod-grid">
                    <!-- Modulation routings -->
                </div>
            </section>

            <!-- VISUALIZER (Middle) -->
            <section class="module visualizer-module">
                <h2>SCOPE / SPEC</h2>
                <div class="visualizer-container" id="vis-container">
                    <canvas id="vis-canvas"></canvas>
                </div>
            </section>
        </main>

    </div>

    <!-- Inlined Scripts for Local Execution -->
    <script>
        // AUDIO CORE
        class AudioCore {
            constructor() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.context.createGain();
                this.masterGain.gain.value = 0.5;

                // Master EQ
                this.adminLow = this.context.createBiquadFilter();
                this.adminLow.type = 'lowshelf';
                this.adminLow.frequency.value = 200;

                this.adminHigh = this.context.createBiquadFilter();
                this.adminHigh.type = 'highshelf';
                this.adminHigh.frequency.value = 2500;

                this.masterGain.connect(this.adminLow);
                this.adminLow.connect(this.adminHigh);
                this.adminHigh.connect(this.context.destination);

                // 1. SEQUENCER VOICE PATH
                // Bus for Osc 1-6
                this.voiceMixer = this.context.createGain();

                // Voice Shaping (VCF -> VCA)
                this.filter = this.context.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 5000;
                this.filter.Q.value = 1;

                // Global LFO
                this.lfo = this.context.createOscillator();
                this.lfo.frequency.value = 1.0;
                this.lfo.start();

                // 1. LFO -> Filter Gain
                this.lfoFilterGain = this.context.createGain();
                this.lfoFilterGain.gain.value = 0;
                this.lfo.connect(this.lfoFilterGain);
                this.lfoFilterGain.connect(this.filter.frequency);

                // 2. LFO -> Pitch Gain (Vibrato)
                this.lfoPitchGain = this.context.createGain();
                this.lfoPitchGain.gain.value = 0; // 0 to 100 cents
                this.lfo.connect(this.lfoPitchGain);

                // 3. LFO -> Filter Res (Q)
                this.lfoResGain = this.context.createGain();
                this.lfoResGain.gain.value = 0;
                this.lfo.connect(this.lfoResGain);
                this.lfoResGain.connect(this.filter.Q);

                // 4. LFO -> Volume (Tremolo)
                this.lfoTremoloGain = this.context.createGain();
                this.lfoTremoloGain.gain.value = 0;
                this.lfo.connect(this.lfoTremoloGain);

                this.tremoloNode = this.context.createGain();
                this.tremoloNode.gain.value = 1;
                this.lfoTremoloGain.connect(this.tremoloNode.gain);

                // 5. LFO -> PAN (AutoPan Main)
                this.lfoPanGain = this.context.createGain();
                this.lfoPanGain.gain.value = 0;
                this.lfo.connect(this.lfoPanGain);
                // Connect to voice panners later? Or global panner?
                // Let's use a Global Panner for Voices
                this.voicePanner = this.context.createStereoPanner();
                this.lfoPanGain.connect(this.voicePanner.pan);

                // Envelope Settings
                this.filterEnv = { amount: 0, attack: 0.05, decay: 0.5 };
                this.pitchEnv = { amount: 0, attack: 0.05, decay: 0.2 };

                this.vca = this.context.createGain();
                this.vca.gain.value = 0;

                // Routing: Voice -> Filter -> VCA -> Tremolo -> PRE-FX SUM
                this.voiceMixer.connect(this.filter);
                this.filter.connect(this.vca);
                this.vca.connect(this.tremoloNode);

                // 2. DRONE PATH
                // Bus for Osc 7
                this.droneMixer = this.context.createGain();
                this.droneGain = this.context.createGain();
                this.droneGain.gain.value = 1.0; // Always open, volume controlled by mixer/osc

                // Routing: Drone -> DroneGain -> PRE-FX SUM
                this.droneMixer.connect(this.droneGain);

                // 3. FX INTEGRATION
                // Both paths meet at FX Input
                this.preFxMix = this.context.createGain();

                // Route Voice -> Panner -> Mix
                this.tremoloNode.disconnect();
                this.tremoloNode.connect(this.voicePanner);
                this.voicePanner.connect(this.preFxMix);

                this.droneGain.connect(this.preFxMix);

                this.output = this.preFxMix; // This connects to FX Engine Input

                this.oscillators = [];
                this.initOscillators();

                // Global Settings
                this.globalOctave = 0;
                this.lastNote = 440;

                // Analyzer
                this.analyser = this.context.createAnalyser();
                // Analyzer
                this.analyser = this.context.createAnalyser();
                this.adminHigh.connect(this.analyser); // Connect after EQ
            }

            initOscillators() {
                const types = [
                    { name: 'OSC 1 Sine', type: 'sine', isDrone: false },
                    { name: 'OSC 2 Saw', type: 'sawtooth', isDrone: false },
                    { name: 'OSC 3 Square', type: 'square', isDrone: false },
                    { name: 'OSC 4 Tri', type: 'triangle', isDrone: false },
                    { name: 'OSC 5 Pulse', type: 'square', isDrone: false },
                    { name: 'OSC 6 Noise', type: 'custom-noise', isDrone: false },
                    { name: 'OSC 7 Sub', type: 'sine', isDrone: false },
                    { name: 'OSC 8 Saw2', type: 'sawtooth', isDrone: false },
                    { name: 'OSC 9 Sqr2', type: 'square', isDrone: false },
                    { name: 'DRONE (Indep)', type: 'custom-drone', isDrone: true }
                ];

                types.forEach((cfg, index) => {
                    const dest = cfg.isDrone ? this.droneMixer : this.voiceMixer;
                    const osc = new OscillatorChannel(this, dest, cfg, index);
                    this.oscillators.push(osc);
                });
            }

            setOctave(offset) {
                this.globalOctave = Math.max(-2, Math.min(2, this.globalOctave + offset));
                return this.globalOctave;
            }

            resume() {
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
            }

            noteOn(freq) {
                this.lastNote = freq;
                const octaveMultiplier = Math.pow(2, this.globalOctave);
                const finalFreq = freq * octaveMultiplier;

                // Update Pitch for ALL oscillators
                this.oscillators.forEach(osc => osc.setFrequency(finalFreq));

                // Trigger Envelope and Filter Env
                if (!this.isDroneMode) {
                    const now = this.context.currentTime;

                    // Pitch Envelope (Zap)
                    if (this.pitchEnv && this.pitchEnv.amount !== 0) {
                        this.oscillators.forEach(osc => {
                            if (!osc.config.isDrone && osc.oscNode && osc.oscNode.detune) {
                                osc.oscNode.detune.cancelScheduledValues(now);
                                osc.oscNode.detune.setValueAtTime(this.pitchEnv.amount, now);
                                osc.oscNode.detune.setTargetAtTime(0, now, this.pitchEnv.decay);
                            }
                        });
                    }

                    // Amp Envelope
                    this.vca.gain.cancelScheduledValues(now);
                    this.vca.gain.setValueAtTime(0, now);
                    this.vca.gain.linearRampToValueAtTime(1, now + 0.01);

                    // Filter Envelope
                    this.triggerFilterEnv(now);
                }
            }

            // Helper to set filter base frequency without breaking connections
            setFilterCutoff(val) {
                this.filterCutoff = val;
                this.filter.frequency.value = val;
            }

            triggerFilterEnv(time) {
                if (this.filterEnv.amount === 0) return;
                const startFreq = this.filterCutoff || 5000;
                const peakFreq = Math.min(22000, startFreq + this.filterEnv.amount);

                this.filter.frequency.cancelScheduledValues(time);
                this.filter.frequency.setValueAtTime(startFreq, time);
                this.filter.frequency.linearRampToValueAtTime(peakFreq, time + this.filterEnv.attack);
                this.filter.frequency.exponentialRampToValueAtTime(startFreq, time + this.filterEnv.attack + this.filterEnv.decay);
            }

            noteOff() {
                // Close Envelope for VOICES only
                const now = this.context.currentTime;
                this.vca.gain.cancelScheduledValues(now);
                this.vca.gain.linearRampToValueAtTime(0, now + 0.1);
            }

            scheduleNote(freq, time, duration) {
                const octaveMultiplier = Math.pow(2, this.globalOctave);
                const finalFreq = freq * octaveMultiplier;

                this.oscillators.forEach(osc => {
                    // Sequencer modulates non-drone voices. 
                    // Drone holds steady (or manual pitch).
                    if (!osc.config.isDrone) {
                        osc.setFrequency(finalFreq, time);
                    }
                });

                // Envelope affecting only Voices
                this.vca.gain.cancelScheduledValues(time);
                this.vca.gain.setValueAtTime(0, time);
                this.vca.gain.linearRampToValueAtTime(1, time + 0.01);
                this.vca.gain.linearRampToValueAtTime(0, time + duration);

                this.triggerFilterEnv(time);
            }
        }



        class OscillatorChannel {
            constructor(audioCoreOrContext, destination, config, index) {
                // Handle legacy or new signature
                if (audioCoreOrContext.constructor.name === 'AudioCore') {
                    this.audioCore = audioCoreOrContext;
                    this.context = this.audioCore.context;
                } else {
                    this.context = audioCoreOrContext;
                    this.audioCore = null;
                }

                this.config = config;
                this.index = index;
                this.active = false;

                // Nodes: Osc -> Gain -> Panner -> Dest
                this.panner = this.context.createStereoPanner();
                this.gainNode = this.context.createGain();
                this.gainNode.gain.value = 0;

                this.gainNode.connect(this.panner);
                this.panner.connect(destination);

                this.oscNode = null;
                this.type = config.type;
                this.baseFreq = 440;

                // Tuning params
                this.detuneFine = 0; // cents
                this.detuneSemi = 0; // semitones

                if (!['custom-noise', 'custom-drone'].includes(this.type)) {
                    this.startOsc();
                }
            }

            setPan(val) {
                // val -1 to 1
                this.panner.pan.value = parseFloat(val);
            }

            setFine(val) {
                // val -50 to 50
                this.detuneFine = parseFloat(val);
                this.updatePitch();
            }

            setSemi(val) {
                // val -12 to 12
                this.detuneSemi = parseFloat(val);
                this.updatePitch();
            }

            updatePitch() {
                if (this.oscNode && this.oscNode.detune) {
                    const totalDetune = (this.detuneSemi * 100) + this.detuneFine;
                    // For non-drone, we rely on noteOn to set base freq, but detune is offset
                    // If note is playing, we can just update detune.
                    // However, we want these knobs to be RELATIVE to the played note.
                    // The noteOn sets frequency. The detune doubles as offset.
                    // BUT noteOn sets detune to 0? No, noteOn calculates freq.
                    // Let's rely on standard WebAudio detune property which sums with frequency.
                    // But wait, our noteOn uses setTargetAtTime which might override?
                    // No, frequency and detune sum up.
                    this.oscNode.detune.value = totalDetune + ((this.index - 3) * 2); // Keep subtle spread
                }
            }

            startOsc() {
                if (this.oscNode) {
                    try { this.oscNode.stop(); } catch (e) { }
                    this.oscNode.disconnect();
                }

                if (this.type === 'custom-noise') {
                    this.oscNode = this.createNoiseNode();
                } else if (this.type === 'custom-drone') {
                    this.oscNode = this.createDroneNode();
                } else {
                    this.oscNode = this.context.createOscillator();
                    this.oscNode.type = this.type;
                    this.oscNode.frequency.value = this.baseFreq;
                    this.oscNode.start();
                }

                if (this.oscNode && this.oscNode.detune && this.audioCore && this.audioCore.lfoPitchGain) {
                    this.audioCore.lfoPitchGain.connect(this.oscNode.detune);
                }

                this.updatePitch(); // Apply current knobs

                this.oscNode.connect(this.gainNode);
            }

            // ... rest keep existing structure but ensure updatePitch is called if frequency changes?
            // Actually setFrequency is called by sequencer.
            setFrequency(freq, time = 0) {
                if (time === 0) time = this.context.currentTime;
                this.baseFreq = freq;
                if (this.oscNode && this.oscNode.frequency) {
                    this.oscNode.frequency.setTargetAtTime(freq, time, 0.01);
                    // We don't touch detune here so knobs persist
                }
            }

            toggle(isActive) {
                this.active = isActive;
                const now = this.context.currentTime;
                this.gainNode.gain.cancelScheduledValues(now);
                this.gainNode.gain.setTargetAtTime(isActive ? 0.5 : 0, now, 0.02);
                // Update Volume Target if needed
                if (isActive && this.targetVolume !== undefined) {
                    this.gainNode.gain.setTargetAtTime(this.targetVolume, now, 0.02);
                }
            }

            setType(type) {
                this.type = type;
                this.startOsc();
            }

            setVolume(val) {
                this.targetVolume = parseFloat(val);
                if (this.active) {
                    this.gainNode.gain.setTargetAtTime(this.targetVolume, this.context.currentTime, 0.02);
                }
            }
        }

        // FX ENGINE
        class FXEngine {
            constructor(context) {
                this.context = context;
                this.input = this.context.createGain();
                this.output = this.context.createGain();

                this.effects = [];
                this.effectNodes = [];

                this.initEffects();
                this.buildChain();
            }

            initEffects() {
                const fxList = [
                    { id: 'delay', name: 'DELAY', type: 'delay' },
                    { id: 'reverb', name: 'REVERB', type: 'reverb' },
                    { id: 'dist', name: 'DISTORTION', type: 'distortion' },
                    { id: 'bit', name: 'BITCRUSH', type: 'bitcrusher' },
                    { id: 'filter', name: 'FILTER FX', type: 'filter' },
                    { id: 'tremolo', name: 'TREMOLO', type: 'tremolo' },
                    { id: 'chorus', name: 'CHORUS', type: 'chorus' },
                    { id: 'phaser', name: 'PHASER', type: 'phaser' },
                    { id: 'ring', name: 'RING MOD', type: 'ringmod' },
                    { id: 'width', name: 'ST-WIDTH', type: 'width' },
                    { id: 'comp', name: 'COMPRESSOR', type: 'compressor' },
                    { id: 'enhancer', name: 'ENHANCER', type: 'enhancer' },
                    { id: 'flanger', name: 'FLANGER', type: 'flanger' },
                    { id: 'autopan', name: 'AUTOPAN', type: 'autopan' },
                    { id: 'overdrive', name: 'OVERDRIVE', type: 'overdrive' },
                    { id: 'pingpong', name: 'PINGPONG', type: 'pingpong' },
                    { id: 'saturator', name: 'SATURATOR', type: 'distortion' },
                    { id: 'lofi', name: 'LO-FI', type: 'bitcrusher' },
                    { id: 'cabinet', name: 'CABINET', type: 'filter' },
                    { id: 'expander', name: 'EXPANDER', type: 'enhancer' }
                ];

                fxList.forEach(fx => {
                    const effect = new Effect(this.context, fx);
                    this.effects.push(effect);
                });
            }

            buildChain() {
                this.input.disconnect();
                this.effects.forEach(fx => fx.output.disconnect());

                let currentSrc = this.input;
                this.effects.forEach(fx => {
                    currentSrc.connect(fx.input);
                    currentSrc = fx.output;
                });

                currentSrc.connect(this.output);
            }

            getEffect(id) {
                return this.effects.find(e => e.config.id === id);
            }
        }

        class Effect {
            constructor(context, config) {
                this.context = context;
                this.config = config;
                this.active = false;

                this.input = context.createGain();
                this.output = context.createGain();

                this.dryGain = context.createGain();
                this.wetGain = context.createGain();
                this.wetGain.gain.value = 0;
                this.dryGain.gain.value = 1;

                this.input.connect(this.dryGain);
                this.dryGain.connect(this.output);
                this.wetGain.connect(this.output);

                this.initNode();
            }

            initNode() {
                switch (this.config.type) {
                    case 'delay':
                        this.node = this.context.createDelay();
                        this.node.delayTime.value = 0.3;
                        this.feedback = this.context.createGain();
                        this.feedback.gain.value = 0.4;
                        this.node.connect(this.feedback);
                        this.feedback.connect(this.node);
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                    case 'reverb':
                        this.node = this.context.createConvolver();
                        const rate = this.context.sampleRate;
                        const length = rate * 2;
                        const decay = 2.0;
                        const imp = this.context.createBuffer(2, length, rate);
                        const L = imp.getChannelData(0); const R = imp.getChannelData(1);
                        for (let i = 0; i < length; i++) {
                            const n = (length - i) / length;
                            L[i] = (Math.random() * 2 - 1) * Math.pow(n, decay);
                            R[i] = (Math.random() * 2 - 1) * Math.pow(n, decay);
                        }
                        this.node.buffer = imp;
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                    case 'distortion':
                    case 'bitcrusher':
                        this.node = this.context.createWaveShaper();
                        this.node.curve = this.makeDistortionCurve(this.config.type === 'bitcrusher' ? 1000 : 400);
                        this.node.oversample = '4x';
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                    case 'filter':
                        this.node = this.context.createBiquadFilter();
                        this.node.type = 'highpass';
                        this.node.frequency.value = 1000;
                        this.node.Q.value = 5;
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                    case 'tremolo':
                        this.lfo = this.context.createOscillator();
                        this.lfo.frequency.value = 4;
                        this.lfoGain = this.context.createGain();
                        this.lfoGain.gain.value = 0.5;
                        this.tremoloGain = this.context.createGain();
                        this.tremoloGain.gain.value = 0.5;
                        this.lfo.connect(this.lfoGain);
                        this.lfoGain.connect(this.tremoloGain.gain);
                        this.lfo.start();
                        this.input.connect(this.tremoloGain);
                        this.tremoloGain.connect(this.wetGain);
                        break;

                    case 'chorus':
                        this.node = this.context.createDelay();
                        this.node.delayTime.value = 0.03;
                        this.choLfo = this.context.createOscillator();
                        this.choLfo.frequency.value = 1.5;
                        this.choLfo.connect(this.node.delayTime);
                        this.choLfo.start();
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                        break;

                    case 'flanger':
                        this.node = this.context.createDelay();
                        this.node.delayTime.value = 0.005;
                        this.lfo = this.context.createOscillator();
                        this.lfo.frequency.value = 0.5;
                        this.lfoGain = this.context.createGain();
                        this.lfoGain.gain.value = 0.002;
                        this.lfo.connect(this.lfoGain);
                        this.lfoGain.connect(this.node.delayTime);
                        this.lfo.start();
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        // Feedback
                        this.fb = this.context.createGain();
                        this.fb.gain.value = 0.5;
                        this.node.connect(this.fb);
                        this.fb.connect(this.node);
                        break;

                    case 'autopan':
                        this.node = this.context.createStereoPanner();
                        this.lfo = this.context.createOscillator();
                        this.lfo.frequency.value = 2;
                        this.lfo.connect(this.node.pan);
                        this.lfo.start();
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                    case 'overdrive':
                        this.node = this.context.createWaveShaper();
                        this.node.curve = this.makeDistortionCurve(1000);
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                    case 'pingpong':
                        this.node = this.context.createDelay();
                        this.node.delayTime.value = 0.4;
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        // Pseudo ping pong by just delaying
                        break;

                    case 'phaser':
                    case 'ringmod':
                    case 'width':
                    case 'compressor':
                    case 'enhancer':
                        this.node = this.context.createGain();
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;

                    default:
                        this.node = this.context.createGain();
                        this.input.connect(this.node);
                        this.node.connect(this.wetGain);
                        break;
                }
            }

            toggle(isActive) {
                this.active = isActive;
                const now = this.context.currentTime;
                this.wetGain.gain.setTargetAtTime(isActive ? 1 : 0, now, 0.1);
                this.dryGain.gain.setTargetAtTime(isActive ? 0 : 1, now, 0.1);
            }

            setParam1(val) { this.setGenericParam(1, val); }
            setParam2(val) { this.setGenericParam(2, val); }

            setGenericParam(num, val) {
                // Map param 1/2 to effect specific props
                const t = this.config.type;
                if (t === 'delay') {
                    if (num === 1) this.node.delayTime.value = val * 1.0; // Time
                    if (num === 2) this.feedback.gain.value = val * 0.95; // FB
                } else if (t === 'reverb') {
                    // Simple convo reverb, maybe gain?
                    // We can't change decay easily without rebuilding buffer.
                    // Let's use gain as a "size/mix" or similar.
                    // Or implement a simple LowPass on the reverb?
                    // Allow input gain?
                } else if (t === 'distortion' || t === 'overdrive') {
                    if (num === 1) this.node.curve = this.makeDistortionCurve(val * 2000); // Drive
                    // Param 2 could be a tone filter?
                } else if (t === 'tremolo') {
                    if (num === 1) this.lfo.frequency.value = val * 20; // Speed
                    if (num === 2) this.lfoGain.gain.value = val; // Depth
                } else if (t === 'flanger') {
                    if (num === 1) this.lfo.frequency.value = val * 5; // Speed
                    if (num === 2) this.fb.gain.value = val * 0.9; // Feedback depth
                } else if (t === 'autopan') {
                    if (num === 1) this.lfo.frequency.value = val * 10;
                } else if (t === 'filter') {
                    if (num === 1) this.node.frequency.value = val * 10000;
                    if (num === 2) this.node.Q.value = val * 20;
                }
                // Add more mappings as needed
            }

            makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50,
                    n_samples = 44100,
                    curve = new Float32Array(n_samples),
                    deg = Math.PI / 180;
                for (let i = 0; i < n_samples; ++i) {
                    let x = i * 2 / n_samples - 1;
                    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }
        }

        // SEQUENCER
        class Sequencer {
            constructor(audioCore) {
                this.audioCore = audioCore;
                this.isPlaying = false;
                this.isRecording = false;

                this.tempo = 120;
                this.currentStep = 0;
                this.nextNoteTime = 0.0;
                this.scheduleAheadTime = 0.1;

                this.selectedNote = 440; // Default A4
                this.selectedNoteName = "A4";

                this.steps = Array(32).fill(null).map(() => ({
                    active: false,
                    note: null,
                    noteName: '',
                    velocity: 0,
                    gate: 0.5
                }));

                this.stepsPerBeat = 4;
                this.timerID = null;
                this.onStepChange = null;
            }

            start() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                this.currentStep = 0;
                this.nextNoteTime = this.audioCore.context.currentTime;
                this.scheduler();
            }

            stop() {
                this.isPlaying = false;
                this.currentStep = 0;
                clearTimeout(this.timerID);
                if (this.onStepChange) this.onStepChange(0);
            }

            toggleRecord() {
                this.isRecording = !this.isRecording;
                return this.isRecording;
            }

            setTempo(bpm) {
                this.tempo = bpm;
            }

            setSelectNote(freq, name) {
                this.selectedNote = freq;
                this.selectedNoteName = name;
            }

            scheduler() {
                while (this.nextNoteTime < this.audioCore.context.currentTime + this.scheduleAheadTime) {
                    this.scheduleNote(this.currentStep, this.nextNoteTime);
                    this.nextStep();
                }
                if (this.isPlaying) {
                    this.timerID = setTimeout(() => this.scheduler(), 25);
                }
            }

            nextStep() {
                const secondsPerBeat = 60.0 / this.tempo;
                const stepTime = 0.25 * secondsPerBeat;
                this.nextNoteTime += stepTime;
                this.currentStep++;
                if (this.currentStep === 32) {
                    this.currentStep = 0;
                }
            }

            scheduleNote(stepNumber, time) {
                if (this.onStepChange) {
                    const drawTime = (time - this.audioCore.context.currentTime) * 1000;
                    setTimeout(() => this.onStepChange(stepNumber), Math.max(0, drawTime));
                }

                const step = this.steps[stepNumber];
                if (step.active && step.note) {
                    this.audioCore.scheduleNote(step.note, time, step.gate * (60 / this.tempo));
                }
            }

            toggleStep(index) {
                const step = this.steps[index];
                if (step.active) {
                    // Check if just updating pitch
                    if (Math.abs(step.note - this.selectedNote) > 0.1) {
                        step.note = this.selectedNote;
                        step.noteName = this.selectedNoteName;
                        return "updated";
                    }
                    step.active = false;
                } else {
                    step.active = true;
                    step.note = this.selectedNote;
                    step.noteName = this.selectedNoteName;
                }
                return step.active ? "active" : "inactive";
            }
        }

        class Knob {
            constructor(container, label, min, max, value, callback) {
                this.min = min;
                this.max = max;
                this.value = value;
                this.callback = callback;

                this.element = document.createElement('div');
                this.element.className = 'knob-wrap';

                this.knob = document.createElement('div');
                this.knob.className = 'knob-dial';

                this.indicator = document.createElement('div');
                this.indicator.className = 'knob-indicator';

                this.knob.appendChild(this.indicator);
                this.element.appendChild(this.knob);

                if (label) {
                    const l = document.createElement('div');
                    l.className = 'knob-label';
                    l.textContent = label;
                    this.element.appendChild(l);
                }

                container.appendChild(this.element);

                this.updateRotation();

                // Events
                let isDragging = false;
                let startY = 0;
                let startVal = 0;

                const handleStart = (y) => {
                    isDragging = true;
                    startY = y;
                    startVal = this.value;
                    document.body.style.cursor = 'ns-resize';
                };

                const handleMove = (y) => {
                    if (!isDragging) return;
                    const dy = startY - y;
                    const range = this.max - this.min;
                    const delta = (dy / 200) * range;

                    let newVal = startVal + delta;
                    newVal = Math.max(this.min, Math.min(this.max, newVal));
                    if (newVal !== this.value) {
                        this.value = newVal;
                        this.updateRotation();
                        this.callback(this.value);
                    }
                };

                const handleEnd = () => {
                    if (isDragging) {
                        isDragging = false;
                        document.body.style.cursor = 'default';
                    }
                };

                // Mouse Events
                this.knob.addEventListener('mousedown', (e) => {
                    handleStart(e.clientY);
                    e.preventDefault();
                });

                window.addEventListener('mousemove', (e) => {
                    handleMove(e.clientY);
                });

                window.addEventListener('mouseup', handleEnd);

                // Touch Events
                this.knob.addEventListener('touchstart', (e) => {
                    handleStart(e.touches[0].clientY);
                    // Prevent page scroll only when starting on knob
                    // Actually touch-action: none on the element is better
                    // e.preventDefault(); 
                }, { passive: false });

                window.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        handleMove(e.touches[0].clientY);
                        if (e.cancelable) e.preventDefault(); // Stop page scroll while dragging
                    }
                }, { passive: false });

                window.addEventListener('touchend', handleEnd);
                window.addEventListener('touchcancel', handleEnd);
            }

            updateRotation() {
                const pct = (this.value - this.min) / (this.max - this.min);
                const angle = -135 + (pct * 270);
                this.knob.style.transform = `rotate(${angle}deg)`;
            }
        }

        // UI CONTROLLER
        class UIController {
            constructor(app) {
                this.app = app;
            }

            async init() {
                this.renderKeyboard();
                this.setupEventListeners();
                this.renderSequencer();
                this.renderOscillators();
                this.renderFX();
                this.renderModMatrix();
                this.setupKeyboard();
                this.startVisualizer();
            }

            renderKeyboard() {
                const container = document.querySelector('.keyboard-controls');
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.alignItems = 'center';
                container.style.background = '#111';
                container.style.padding = '0';
                container.style.borderRadius = '4px';

                // Octave Controls
                const octControls = document.createElement('div');
                octControls.style.width = '100%';
                octControls.style.display = 'flex';
                octControls.style.justifyContent = 'center';
                octControls.style.marginBottom = '2px';
                octControls.innerHTML = `
                   <button class="octave-btn" data-action="down" style="padding: 1px 4px; font-size: 0.55rem;">-</button>
                   <span id="current-octave" style="font-family: var(--font-mono); color: var(--accent-color); font-size: 0.6rem; margin: 0 4px;">OCT 4</span>
                   <button class="octave-btn" data-action="up" style="padding: 1px 4px; font-size: 0.55rem;">+</button>
                `;
                container.appendChild(octControls);

                // Keys Container
                const keysContainer = document.createElement('div');
                keysContainer.id = 'keys-container-wrapper'; // For mobile styling
                keysContainer.style.position = 'relative';
                const isMobile = window.innerWidth <= 768;
                const whiteWidth = isMobile ? 30 : 22;
                const blackWidth = isMobile ? 20 : 14;
                const blackOffset = isMobile ? 20 : 15;
                const keyHeight = isMobile ? 70 : 45;

                keysContainer.style.height = keyHeight + 'px';
                keysContainer.style.display = 'block'; // Changed from flex

                const baseFreq = 130.81; // C3
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

                let whiteIndex = 0;
                for (let i = 0; i < 24; i++) {
                    const n = i % 12;
                    const oct = 3 + Math.floor(i / 12);
                    const freq = baseFreq * Math.pow(2, i / 12);
                    const name = noteNames[n] + oct;
                    const isBlack = [1, 3, 6, 8, 10].includes(n);

                    const btn = document.createElement('div');
                    btn.dataset.freq = freq;
                    btn.dataset.name = name;

                    btn.onclick = () => {
                        this.app.audioCore.noteOn(freq);
                        setTimeout(() => this.app.audioCore.noteOff(), 150);
                        this.app.sequencer.setSelectNote(freq, name);
                        document.querySelectorAll('.piano-key').forEach(k => k.classList.remove('active-note'));
                        btn.classList.add('active-note');
                    };

                    if (!isBlack) {
                        btn.className = 'piano-key white';
                        btn.style.left = (whiteIndex * whiteWidth) + 'px';
                        btn.style.width = whiteWidth + 'px';
                        btn.style.height = keyHeight + 'px';
                        btn.style.position = 'absolute';
                        whiteIndex++;
                    } else {
                        btn.className = 'piano-key black';
                        btn.style.left = ((whiteIndex - 1) * whiteWidth + blackOffset) + 'px';
                        btn.style.width = blackWidth + 'px';
                        btn.style.height = (keyHeight * 0.6) + 'px';
                        btn.style.position = 'absolute';
                        btn.style.zIndex = '30';
                    }
                    keysContainer.appendChild(btn);
                }

                keysContainer.style.width = (whiteIndex * whiteWidth) + 'px';
                container.appendChild(keysContainer);

                octControls.querySelectorAll('.octave-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const action = btn.dataset.action;
                        const val = action === 'up' ? 1 : -1;
                        const newOct = this.app.audioCore.setOctave(val);
                        container.querySelector('#current-octave').textContent = `OCT ${4 + newOct}`;
                    });
                });
            }

            setupEventListeners() {
                const masterBox = document.getElementById('master-knobs');
                new Knob(masterBox, 'VOL', 0, 1, 0.8, v => this.app.audioCore.masterGain.gain.value = v);
                new Knob(masterBox, 'LOW', -10, 10, 0, v => this.app.audioCore.adminLow.gain.value = v);
                new Knob(masterBox, 'HIGH', -10, 10, 0, v => this.app.audioCore.adminHigh.gain.value = v);

                document.getElementById('power-btn').addEventListener('click', () => {
                    this.app.audioCore.resume();
                    document.getElementById('power-btn').classList.add('active');
                });

                document.getElementById('seq-play').addEventListener('click', () => {
                    this.app.sequencer.start();
                });
                document.getElementById('seq-stop').addEventListener('click', () => {
                    this.app.sequencer.stop();
                    document.querySelectorAll('.step-btn').forEach(b => b.classList.remove('current'));
                });
                document.getElementById('seq-stop').addEventListener('click', () => {
                    this.app.sequencer.stop();
                    document.querySelectorAll('.step-btn').forEach(b => b.classList.remove('current'));
                });
                // Remove REC listener
                document.getElementById('bpm-input').addEventListener('change', (e) => {
                    this.app.sequencer.setTempo(e.target.value);
                });
            }

            renderSequencer() {
                const grid = document.getElementById('step-grid');
                grid.innerHTML = '';
                for (let i = 0; i < 32; i++) {
                    const step = document.createElement('div');
                    step.className = 'step-btn';
                    step.dataset.index = i;

                    const label = document.createElement('div');
                    label.style.fontSize = '0.7em';
                    label.style.pointerEvents = 'none';
                    step.appendChild(label);

                    step.addEventListener('click', () => {
                        const status = this.app.sequencer.toggleStep(i);
                        const stepData = this.app.sequencer.steps[i];

                        if (status === 'active' || status === 'updated') {
                            step.classList.add('enabled');
                            // Color code by pitch class (0-11)
                            // const hue = (Math.log2(stepData.note/440)*12 % 12) * 30; // Approx hue
                            step.style.borderColor = 'var(--text-color)';
                            label.textContent = stepData.noteName || '';
                        } else {
                            step.classList.remove('enabled');
                            step.style.borderColor = '#333';
                            label.textContent = '';
                        }
                    });
                    grid.appendChild(step);
                }
                this.app.sequencer.onStepChange = (stepIndex) => {
                    const steps = document.querySelectorAll('.step-btn');
                    steps.forEach(s => s.classList.remove('current'));
                    if (steps[stepIndex]) steps[stepIndex].classList.add('current');
                };
            }

            renderOscillators() {
                const container = document.getElementById('osc-container');
                container.innerHTML = '';
                this.app.audioCore.oscillators.forEach((osc, idx) => {
                    const strip = document.createElement('div');
                    strip.className = 'osc-strip';
                    strip.style.display = 'flex';
                    strip.style.alignItems = 'center';
                    strip.style.gap = '2px';
                    strip.style.padding = '0 2px'; // Tighter padding
                    strip.style.height = '28px'; // Even more compact height
                    strip.style.borderBottom = '1px solid #222';

                    // Name
                    const label = document.createElement('span');
                    label.textContent = osc.config.name.replace('OSC ', '').replace(' ', '');
                    label.style.width = '40px';
                    label.style.fontSize = '0.6rem';
                    label.style.color = '#888';

                    // Toggle
                    const toggle = document.createElement('button');
                    toggle.textContent = '';
                    toggle.style.width = '12px';
                    toggle.style.height = '12px';
                    toggle.style.background = '#333';
                    toggle.style.border = 'none';
                    toggle.style.borderRadius = '50%';
                    toggle.style.marginRight = '5px';

                    const updateToggle = () => {
                        toggle.style.background = osc.active ? 'var(--accent-color)' : '#333';
                        toggle.style.boxShadow = osc.active ? 'var(--accent-glow)' : 'none';
                    };
                    toggle.onclick = () => {
                        osc.toggle(!osc.active);
                        updateToggle();
                    };
                    updateToggle();

                    // Wave Type (Small icon/select)
                    const typeSel = document.createElement('select');
                    typeSel.style.width = '45px';
                    typeSel.style.fontSize = '0.6rem';
                    typeSel.style.background = 'transparent';
                    typeSel.style.color = '#ccc';
                    typeSel.style.border = 'none';
                    ['sine', 'square', 'sawtooth', 'triangle'].forEach(t => {
                        const opt = document.createElement('option');
                        opt.value = t; opt.textContent = t.substr(0, 4).toUpperCase();
                        typeSel.appendChild(opt);
                    });
                    typeSel.value = osc.config.type;
                    typeSel.onchange = (e) => osc.setType(e.target.value);

                    // Knobs Container
                    const knobs = document.createElement('div');
                    knobs.style.display = 'flex';
                    knobs.style.gap = '4px';
                    knobs.style.marginLeft = '10px'; // No longer auto (far right), just a bit of spacing
                    knobs.style.transform = 'scale(0.9)';

                    // 1. SEMI (-12 to 12)
                    const mkOscKnob = (name, min, max, val, fn) => {
                        const d = document.createElement('div');
                        new Knob(d, name, min, max, val, fn);
                        return d;
                    };

                    knobs.appendChild(mkOscKnob('SEMI', -12, 12, 0, v => osc.setSemi(v)));
                    knobs.appendChild(mkOscKnob('FINE', -50, 50, 0, v => osc.setFine(v)));
                    knobs.appendChild(mkOscKnob('PAN', -1, 1, 0, v => osc.setPan(v)));
                    knobs.appendChild(mkOscKnob('VOL', 0, 1, 0.5, v => osc.setVolume(v)));

                    strip.appendChild(toggle);
                    strip.appendChild(label);
                    strip.appendChild(typeSel);
                    strip.appendChild(knobs);
                    container.appendChild(strip);
                });
            }

            renderFX() {
                const container = document.getElementById('fx-grid');
                container.innerHTML = '';
                container.style.display = 'grid';
                container.style.gridTemplateColumns = 'repeat(4, 1fr)'; // 4 columns
                container.style.gap = '2px';
                container.style.overflowY = 'auto'; // allow scroll if needed but try to fit

                this.app.fxEngine.effects.forEach(fx => {
                    const card = document.createElement('div');
                    card.className = 'fx-card';
                    card.style.background = '#0e0e0e';
                    card.style.border = '1px solid #222';
                    card.style.padding = '1px'; // Min padding
                    card.style.fontSize = '0.55rem'; // Smaller font
                    card.style.display = 'flex';
                    card.style.flexDirection = 'column';
                    card.style.alignItems = 'center';

                    // Header: Name + Toggle
                    const head = document.createElement('div');
                    head.style.display = 'flex';
                    head.style.justifyContent = 'space-between';
                    head.style.width = '100%';
                    head.style.marginBottom = '2px';

                    const name = document.createElement('span');
                    name.textContent = fx.config.name;
                    name.style.fontWeight = 'bold';
                    name.style.fontSize = '0.55rem';

                    const tog = document.createElement('div');
                    tog.style.width = '8px';
                    tog.style.height = '8px';
                    tog.style.borderRadius = '50%';
                    tog.style.background = '#333';
                    tog.style.cursor = 'pointer';
                    tog.onclick = () => {
                        const newState = !fx.active;
                        fx.toggle(newState);
                        tog.style.background = newState ? 'var(--accent-color)' : '#333';
                        tog.style.boxShadow = newState ? 'var(--accent-glow)' : 'none';
                    };

                    head.appendChild(name);
                    head.appendChild(tog);
                    card.appendChild(head);

                    // Knobs Row
                    const kRow = document.createElement('div');
                    kRow.style.display = 'flex';
                    kRow.style.gap = '2px';

                    const mkKnob = (l, def, fn) => {
                        const w = document.createElement('div');
                        new Knob(w, l, 0, 1, def, fn);
                        // Hack: scale down knobs for FX card
                        w.style.transform = 'scale(0.75)'; // Smaller scale
                        w.style.width = '20px'; // force squeeze
                        return w;
                    };

                    kRow.appendChild(mkKnob('P1', 0.5, v => fx.setParam1(v)));
                    kRow.appendChild(mkKnob('P2', 0.5, v => fx.setParam2(v)));
                    kRow.appendChild(mkKnob('MIX', 0, v => {
                        fx.wetGain.gain.value = v;
                        fx.dryGain.gain.value = 1 - v;
                    }));

                    card.appendChild(kRow);
                    container.appendChild(card);
                });
            }

            renderModMatrix() {
                const container = document.getElementById('mod-grid');
                container.innerHTML = '';
                container.style.display = 'grid';
                container.style.gridTemplateColumns = 'repeat(4, 1fr)';
                container.style.gap = '4px';

                // 1. MASTER FILTER
                const masterFilt = this.createModCard('MST FILT', (v) => {
                    this.app.audioCore.filter.Q.value = parseFloat(v);
                }, (v) => {
                    this.app.audioCore.filterCutoff = parseFloat(v);
                    this.app.audioCore.filter.frequency.value = parseFloat(v);
                }, { speedMin: 0.1, speedMax: 20, speedVal: 1, depthMin: 20, depthMax: 10000, depthVal: 5000 });
                masterFilt.querySelector('.spd-label').textContent = 'RES';
                masterFilt.querySelector('.dpt-label').textContent = 'CUT';
                container.appendChild(masterFilt);

                // 2. LFO -> FILTER
                const lfoFilt = this.createModCard('LFO->FILT', (v) => {
                    this.app.audioCore.lfo.frequency.value = parseFloat(v);
                }, (v) => {
                    this.app.audioCore.lfoFilterGain.gain.value = parseFloat(v);
                }, { speedMin: 0.1, speedMax: 20, speedVal: 1, depthMin: 0, depthMax: 5000, depthVal: 0 });
                container.appendChild(lfoFilt);

                // 3. LFO -> PITCH
                const lfoPitch = this.createModCard('LFO->PIT', (v) => {
                    this.app.audioCore.lfo.frequency.value = parseFloat(v);
                }, (v) => {
                    this.app.audioCore.lfoPitchGain.gain.value = parseFloat(v);
                }, { speedMin: 0.1, speedMax: 20, speedVal: 1, depthMin: 0, depthMax: 500, depthVal: 0 });
                container.appendChild(lfoPitch);

                // 4. ENV -> FILTER
                const envFilt = this.createModCard('ENV->FILT', (v) => {
                    this.app.audioCore.filterEnv.attack = parseFloat(v);
                }, (v) => {
                    this.app.audioCore.filterEnv.amount = parseFloat(v);
                }, { speedMin: 0.01, speedMax: 1, speedVal: 0.05, depthMin: 0, depthMax: 10000, depthVal: 0 });
                const labels = envFilt.querySelectorAll('.knob-label');
                if (labels[0]) labels[0].textContent = 'ATK';
                if (labels[1]) labels[1].textContent = 'AMT';
                container.appendChild(envFilt);

                // 5. LFO -> VOL (Tremolo)
                const lfoVol = this.createModCard('LFO->VOL', (v) => {
                    this.app.audioCore.lfo.frequency.value = parseFloat(v);
                }, (v) => {
                    if (this.app.audioCore.lfoTremoloGain) this.app.audioCore.lfoTremoloGain.gain.value = parseFloat(v);
                }, { speedMin: 0.1, speedMax: 20, speedVal: 1, depthMin: 0, depthMax: 1, depthVal: 0 });
                container.appendChild(lfoVol);

                // 6. LFO -> RES
                const lfoRes = this.createModCard('LFO->RES', (v) => {
                    this.app.audioCore.lfo.frequency.value = parseFloat(v);
                }, (v) => {
                    if (this.app.audioCore.lfoResGain) this.app.audioCore.lfoResGain.gain.value = parseFloat(v);
                }, { speedMin: 0.1, speedMax: 20, speedVal: 1, depthMin: 0, depthMax: 30, depthVal: 0 });
                container.appendChild(lfoRes);

                // 7. ENV -> PITCH
                const envPit = this.createModCard('ENV->PIT', (v) => {
                    if (this.app.audioCore.pitchEnv) this.app.audioCore.pitchEnv.attack = parseFloat(v);
                }, (v) => {
                    if (this.app.audioCore.pitchEnv) this.app.audioCore.pitchEnv.amount = parseFloat(v);
                }, { speedMin: 0.01, speedMax: 1, speedVal: 0.05, depthMin: 0, depthMax: 1000, depthVal: 0 });
                const plabels = envPit.querySelectorAll('.knob-label');
                if (plabels[0]) plabels[0].textContent = 'ATK';
                if (plabels[1]) plabels[1].textContent = 'AMT';
                container.appendChild(envPit);

                // 8. LFO -> PAN
                const lfoPan = this.createModCard('LFO->PAN', (v) => {
                    this.app.audioCore.lfo.frequency.value = parseFloat(v);
                }, (v) => {
                    if (this.app.audioCore.lfoPanGain) this.app.audioCore.lfoPanGain.gain.value = parseFloat(v);
                }, { speedMin: 0.1, speedMax: 20, speedVal: 1, depthMin: 0, depthMax: 1, depthVal: 0 });
                container.appendChild(lfoPan);
            }

            createModCard(title, onSpeed, onDepth, config) {
                const card = document.createElement('div');
                card.style.background = '#0a0a0a';
                card.style.padding = '3px';
                card.style.borderRadius = '2px';
                card.style.fontSize = '0.65rem';
                card.style.border = '1px solid #222';

                const head = document.createElement('div');
                head.textContent = title;
                head.style.color = 'var(--accent-color)';
                head.style.fontWeight = 'bold';
                head.style.marginBottom = '2px';
                card.appendChild(head);

                const createKnob = (label, min, max, val, onInput, className) => {
                    const wrap = document.createElement('div');
                    wrap.style.marginBottom = '2px';
                    wrap.innerHTML = `<div class="${className}" style="color:#666; font-size: 0.5rem;">${label}</div>`;
                    const input = document.createElement('input');
                    input.type = 'range';
                    input.min = min;
                    input.max = max;
                    input.step = (max - min) / 100;
                    input.value = val;
                    input.style.width = '100%';
                    input.oninput = (e) => onInput(e.target.value);
                    wrap.appendChild(input);
                    return wrap;
                };

                card.appendChild(createKnob('SPD', config.speedMin, config.speedMax, config.speedVal, onSpeed, 'spd-label'));
                card.appendChild(createKnob('DPT', config.depthMin, config.depthMax, config.depthVal, onDepth, 'dpt-label'));

                return card;
            }

            setupKeyboard() {
                window.addEventListener('keydown', (e) => {
                    const keyMap = {
                        'z': 261.63, 's': 277.18, 'x': 293.66, 'd': 311.13, 'c': 329.63, 'v': 349.23,
                        'g': 369.99, 'b': 392.00, 'h': 415.30, 'n': 440.00, 'j': 466.16, 'm': 493.88, ',': 523.25
                    };
                    if (keyMap[e.key] && !e.repeat) this.app.audioCore.noteOn(keyMap[e.key]);
                });
                window.addEventListener('keyup', (e) => {
                    const keyMap = { 'z': 1, 's': 1, 'x': 1, 'd': 1, 'c': 1, 'v': 1, 'g': 1, 'b': 1, 'h': 1, 'n': 1, 'j': 1, 'm': 1, ',': 1 };
                    if (keyMap[e.key]) this.app.audioCore.noteOff();
                });
            }

            startVisualizer() {
                const container = document.getElementById('vis-container');
                const canvas = document.getElementById('vis-canvas');
                const ctx = canvas.getContext('2d');

                const analyser = this.app.audioCore.analyser;
                analyser.fftSize = 512;
                const bufferLength = analyser.frequencyBinCount;
                const timeData = new Uint8Array(bufferLength);
                const freqData = new Uint8Array(bufferLength);

                let particles = [];
                const maxParticles = 1500; // Condensed for smaller screen
                let hueBase = 0;

                // Advanced Resize Observer for perfect scaling on any monitor
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        canvas.width = width;
                        canvas.height = height;
                    }
                });
                resizeObserver.observe(container);

                class Particle {
                    constructor(w, h) {
                        this.init(w, h);
                    }

                    init(w, h, explode = false) {
                        this.x = w / 2;
                        this.y = h / 2;

                        // "Circle" emitter
                        const angle = Math.random() * Math.PI * 2;
                        // Smaller radius relative to container min dimension
                        const minDim = Math.min(w, h);
                        const radius = explode ? Math.random() * (minDim * 0.4) : (minDim * 0.1) + Math.random() * (minDim * 0.3);

                        this.x += Math.cos(angle) * radius;
                        this.y += Math.sin(angle) * radius;

                        // Chaotic velocity
                        const speed = Math.random() * 2 + 0.5;
                        this.vx = Math.cos(angle) * speed;
                        this.vy = Math.sin(angle) * speed;

                        this.life = 1.0;
                        this.decay = Math.random() * 0.01 + 0.005;
                        this.size = Math.random() * 2 + 0.5; // Slightly smaller particles
                        this.hue = hueBase + Math.random() * 60;
                    }

                    update(w, h, audioMod) {
                        // Eternal Motion & Chaos
                        this.x += this.vx * (1 + audioMod * 2);
                        this.y += this.vy * (1 + audioMod * 2);

                        // Turbulence
                        this.vx += (Math.random() - 0.5) * 0.2;
                        this.vy += (Math.random() - 0.5) * 0.2;

                        this.life -= this.decay;

                        // If dead or out of bounds, respawn
                        if (this.life <= 0 || this.x < 0 || this.x > w || this.y < 0 || this.y > h) {
                            this.init(w, h);
                        }
                    }

                    draw(ctx) {
                        ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, ${this.life})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Initialize random particles
                // We'll init them once we have dimensions in the draw loop if needed, 
                // but easier to just wait for resize or standard init
                // Let's safe-guard against 0 width
                const tryInit = () => {
                    if (canvas.width > 0) {
                        particles = [];
                        for (let i = 0; i < maxParticles; i++) {
                            const p = new Particle(canvas.width, canvas.height);
                            // Scatter initially
                            p.x = Math.random() * canvas.width;
                            p.y = Math.random() * canvas.height;
                            particles.push(p);
                        }
                    } else {
                        requestAnimationFrame(tryInit);
                    }
                }
                setTimeout(tryInit, 100);

                const draw = () => {
                    requestAnimationFrame(draw);

                    const w = canvas.width;
                    const h = canvas.height;

                    if (particles.length === 0 && w > 0) tryInit();

                    // Fade out effect
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(0, 0, w, h);

                    // Get Audio Data
                    analyser.getByteFrequencyData(freqData);
                    analyser.getByteTimeDomainData(timeData);

                    // Calculate Average Volume / Energy
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) sum += freqData[i];
                    const avg = sum / bufferLength;
                    const audioMod = avg / 128.0;

                    hueBase += 0.5 + audioMod;

                    // "Circle" chaos in center (Outline)
                    ctx.beginPath();
                    ctx.strokeStyle = `hsl(${hueBase}, 100%, 50%)`;
                    ctx.lineWidth = 1 + audioMod * 3;
                    const centerRadius = (Math.min(w, h) * 0.2) + audioMod * 20;
                    ctx.arc(w / 2, h / 2, centerRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Particles
                    ctx.globalCompositeOperation = 'lighter';
                    particles.forEach(p => {
                        p.update(w, h, audioMod);
                        p.draw(ctx);
                    });
                    ctx.globalCompositeOperation = 'source-over';
                };
                draw();
            }
        }

        // APP MAIN
        class App {
            constructor() {
                this.audioCore = new AudioCore();
                this.fxEngine = new FXEngine(this.audioCore.context);
                this.sequencer = new Sequencer(this.audioCore);
                this.ui = new UIController(this);

                this.init();
            }

            async init() {
                console.log('LIVE MODULARXIII Initializing...');
                await this.ui.init();

                // Connect Audio Core -> FX -> Master
                this.audioCore.output.connect(this.fxEngine.input);
                this.fxEngine.output.connect(this.audioCore.masterGain);
            }
        }

        // Start App when DOM is ready
        window.addEventListener('DOMContentLoaded', () => {
            window.app = new App();
        });
    </script>
</body>

</html>
